const axios = require('../axios');
const set = require('lodash/set');
const merge = require('lodash/merge');
const https = require('https');
const fs = require('fs');

// Environment variables injected during generation
const env = {
  directExecute: {{executionConfig.directExecute}},
  mtls: {
    certPath: '{{executionConfig.mtls.certPath}}',
    keyPath: '{{executionConfig.mtls.keyPath}}',
    caPath: '{{executionConfig.mtls.caPath}}',
    rejectUnauthorized: {{executionConfig.mtls.rejectUnauthorized}},
  }
};

const functions = [
{{#each specifications}}
  ['{{#if context}}{{context}}.{{/if}}{{name}}', '{{id}}',{{#each function.arguments}}'{{name}}',{{/each}}],
{{/each}}
];

// Create MTLS agent if paths are provided
let httpsAgent = undefined;
const getHttpsAgent = () => {
  if (httpsAgent) {
    return httpsAgent;
  }

  const { mtls } = env;
  if (!mtls.certPath || !mtls.keyPath || !mtls.caPath) {
    return undefined;
  }

  httpsAgent = new https.Agent({
    cert: fs.readFileSync(mtls.certPath),
    key: fs.readFileSync(mtls.keyPath),
    ca: fs.readFileSync(mtls.caPath),
    rejectUnauthorized: mtls.rejectUnauthorized,
  });

  return httpsAgent;
};

module.exports = (clientID, polyCustom) => merge(
  {},
  functions.reduce(
    (acc, [path, id, ...argKeys]) => set(
      acc,
      path,
      (...args) => {
        const requestServerStartTime = Date.now();
        const requestArgs = argKeys.reduce((acc, key, index) => ({ ...acc, [key]: args[index] }), {});
        
        // Check if direct execution is enabled
        const { directExecute } = env;
        
        if (directExecute === true) {
          // Make direct API call

          let polyHeaders;
          let serverPreperationTimeMs;
          let roundTripServerNetworkLatencyMs;
          let requestApiStartTime;

          return axios.post(
            `/functions/api/${id}/direct-execute?clientId=${clientID}`,
            requestArgs,
            {
              headers: {
                'x-poly-execution-id': polyCustom.executionId,
              }
            }
          ).then(({ headers, data }) => {
            polyHeaders = headers;
            if (data && (data.status < 200 || data.status >= 300)) {
              console.error('Error getting direct execution data for api function with id:', id, 'Status code:', data.status, 'Request data:', requestArgs, 'Response data:', data.data);
            }

            serverPreperationTimeMs = Number(polyHeaders['x-poly-execution-duration']);
            roundTripServerNetworkLatencyMs = Date.now() - requestServerStartTime - serverPreperationTimeMs;

            requestApiStartTime = Date.now();
            const httpsAgent = getHttpsAgent();

            return axios({
              ...data,
              headers: {
                ...data.headers,
              },
              httpsAgent,
            })
          }).then(({ headers, data, status, ...args }) => {
            if (status && (status < 200 || status >= 300)) {
              console.error('Error direct executing api function with id:', id, 'Status code:', status, 'Request data:', requestArgs, 'Response data:', data.data);
            }
            const apiExecutionTimeMs = Date.now() - requestApiStartTime;
            return {
              data: data,
              status: status,
              headers: { ...headers },
              metrics: {
                roundTripServerNetworkLatencyMs,
                serverPreperationTimeMs,
                apiExecutionTimeMs,
              }
            };
          });
        }

        // default indirect execution
        return axios.post(
          `/functions/api/${id}/execute?clientId=${clientID}`,
          {
            ...requestArgs,
          },
          {
            headers: {
              'x-poly-execution-id': polyCustom.executionId,
            }
          }
        ).then(({ headers, data }) => {
          if (data && (data.status < 200 || data.status >= 300)) {
            console.error('Error executing api function with id:', id, 'Status code:', data.status, 'Request data:', requestArgs, 'Response data:', data.data);
          }
          const serverExecutionTimeMs = Number(headers['x-poly-execution-duration']);
          const roundTripNetworkLatencyMs = Date.now() - requestServerStartTime - serverExecutionTimeMs;
          return {
            ...data,
            metrics: {
              roundTripNetworkLatencyMs,
              serverExecutionTimeMs,
            }
          };
        });
      }),
    {}
  )
);
